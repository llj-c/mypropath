# 代码编写规范

本文档定义了基于 pytest 的测试框架项目的代码编写规范，旨在确保代码质量、可维护性和团队协作效率。

## 目录

- [代码风格规范](#代码风格规范)
- [命名规范](#命名规范)
- [文件组织规范](#文件组织规范)
- [测试代码编写规范](#测试代码编写规范)
- [框架代码编写规范](#框架代码编写规范)
- [注释和文档规范](#注释和文档规范)
- [异常处理规范](#异常处理规范)
- [最佳实践](#最佳实践)

---

## 代码风格规范

### 基本规则

1. **缩进**：使用 4 个空格，不使用 Tab
2. **行长度**：最大 88 个字符（由 Ruff formatter 自动处理）
3. **引号**：统一使用双引号（`"`）
4. **编码**：所有文件使用 UTF-8 编码
5. **换行符**：使用 LF（Unix 风格）

### 代码格式化

项目使用 **Ruff** 进行代码格式化和检查，所有代码必须通过 Ruff 检查。

```bash
# 格式化代码
ruff format .

# 检查代码
ruff check .

# 自动修复可修复的问题
ruff check --fix .
```

### 导入顺序

使用 `isort` 规则（已集成在 Ruff 中），导入顺序：

1. 标准库导入
2. 第三方库导入
3. 本地应用/库导入

每组导入之间用空行分隔。

```python
# 标准库
import os
import sys
from typing import Dict, List

# 第三方库
import httpx
import pytest
from playwright.sync_api import Page

# 本地导入
from framework.api.common.base_client import BaseClient
from framework.config.settings import Settings
```

---

## 命名规范

### 变量和函数

- **变量名**：使用小写字母，单词间用下划线分隔（snake_case）
- **函数名**：使用小写字母，单词间用下划线分隔（snake_case）
- **常量**：使用全大写字母，单词间用下划线分隔（UPPER_SNAKE_CASE）

```python
# 变量
user_name = "test_user"
max_retry_count = 3

# 函数
def get_user_info():
    pass

def create_order(order_data):
    pass

# 常量
MAX_TIMEOUT = 30
DEFAULT_BASE_URL = "https://api.example.com"
```

### 类名

- 使用 **PascalCase**（大驼峰命名）
- 类名应该清晰表达其用途

```python
class BaseClient:
    pass

class UserClient(BaseClient):
    pass

class AuthenticationError(Exception):
    pass
```

### 测试相关命名

- **测试文件**：以 `test_` 开头，例如 `test_user_api.py`
- **测试函数**：以 `test_` 开头，描述测试场景
- **测试类**：以 `Test` 开头，使用 PascalCase
- **Fixture**：使用小写下划线命名，例如 `user_client`, `auth_token`

```python
# 测试文件：tests/api/user/test_user_api.py
class TestUserAPI:
    def test_create_user_success(self, user_client):
        """测试成功创建用户"""
        pass
    
    def test_create_user_with_invalid_data(self, user_client):
        """测试使用无效数据创建用户"""
        pass
```

### 私有成员

- 使用单下划线前缀（`_`）表示受保护的成员
- 使用双下划线前缀（`__`）表示私有成员（尽量避免使用）

```python
class BaseClient:
    def __init__(self):
        self._base_url = "https://api.example.com"  # 受保护
        self.__api_key = "secret"  # 私有（不推荐）
```

---

## 文件组织规范

### 目录结构

遵循项目标准目录结构（参考 `docs/测试框架.md`）：

```
framework/          # 框架代码
├── api/            # API 封装
├── ui/             # UI 封装
├── config/         # 配置管理
└── utils/          # 工具类

tests/              # 测试代码
├── api/            # API 测试
├── ui/             # UI 测试
├── integration/    # 集成测试
├── data/           # 测试数据
└── fixtures/       # pytest fixtures
```

### 文件命名

- **Python 文件**：使用小写字母和下划线，例如 `user_client.py`
- **测试文件**：以 `test_` 开头，例如 `test_user_api.py`
- **配置文件**：使用小写字母和下划线，例如 `settings.py`

### 模块导入

每个目录必须包含 `__init__.py` 文件（Python 3.3+ 可以省略，但建议保留以明确包结构）。

---

## 测试代码编写规范

### 测试函数结构

测试函数应遵循 **AAA 模式**（Arrange-Act-Assert）：

```python
def test_user_login_success(user_client):
    """测试用户登录成功"""
    # Arrange: 准备测试数据
    username = "test_user"
    password = "test_password"
    
    # Act: 执行被测试的操作
    response = user_client.login(username, password)
    
    # Assert: 验证结果
    assert response.status_code == 200
    assert response.json()["token"] is not None
```

### 测试命名

- 测试函数名应该清晰描述测试场景
- 使用 `test_` + `模块名` + `_` + `场景` 的格式

```python
# 好的命名
def test_user_create_success():
def test_user_create_with_invalid_email():
def test_user_create_with_duplicate_username():

# 不好的命名
def test_user():
def test_1():
def test_create():
```

### 使用 Fixtures

充分利用 pytest fixtures 来管理测试依赖：

```python
# tests/fixtures/api_fixtures.py
import pytest
from framework.api.modules.user.user_client import UserClient

@pytest.fixture
def user_client():
    """创建用户客户端实例"""
    return UserClient(base_url="https://api.example.com")

@pytest.fixture
def authenticated_user(user_client):
    """创建已认证的用户"""
    user_client.login("test_user", "test_password")
    return user_client
```

### 测试数据管理

- 测试数据放在 `tests/data/` 目录
- 使用数据类或字典定义测试数据
- 避免硬编码，使用配置文件或 fixture

```python
# tests/data/user_data.py
from dataclasses import dataclass

@dataclass
class UserTestData:
    valid_user = {
        "username": "test_user",
        "email": "test@example.com",
        "password": "Test123!@#"
    }
    
    invalid_email_user = {
        "username": "test_user",
        "email": "invalid_email",
        "password": "Test123!@#"
    }
```

### 断言规范

- 使用明确的断言消息
- 优先使用 pytest 的断言，而不是 Python 的 `assert`
- 使用 `pytest.raises` 测试异常

```python
import pytest

def test_user_not_found(user_client):
    """测试用户不存在的情况"""
    with pytest.raises(UserNotFoundError, match="User not found"):
        user_client.get_user(user_id=99999)

def test_response_contains_required_fields(response):
    """测试响应包含必需字段"""
    data = response.json()
    assert "id" in data, "响应中缺少 id 字段"
    assert "username" in data, "响应中缺少 username 字段"
```

### 测试隔离

- 每个测试应该是独立的，不依赖其他测试的执行顺序
- 使用 fixtures 的 `scope` 参数控制资源生命周期
- 测试后清理资源（使用 `yield` fixture 或 `teardown`）

```python
@pytest.fixture
def temp_user(user_client):
    """创建临时用户，测试后删除"""
    user = user_client.create_user({
        "username": "temp_user",
        "email": "temp@example.com"
    })
    yield user
    # 清理
    user_client.delete_user(user["id"])
```

---

## 框架代码编写规范

### API 客户端规范

#### 基础客户端

所有 API 客户端应继承自 `BaseClient`：

```python
# framework/api/modules/user/user_client.py
from framework.api.common.base_client import BaseClient

class UserClient(BaseClient):
    """用户 API 客户端"""
    
    def __init__(self, base_url: str, **kwargs):
        super().__init__(base_url, **kwargs)
        self.endpoint = f"{base_url}/api/users"
    
    def get_user(self, user_id: int) -> dict:
        """获取用户信息"""
        response = self.get(f"{self.endpoint}/{user_id}")
        return response.json()
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户"""
        response = self.post(self.endpoint, json=user_data)
        return response.json()
```

#### 错误处理

- 使用自定义异常类
- 提供清晰的错误信息
- 记录错误日志

```python
# framework/api/common/exceptions.py
class APIError(Exception):
    """API 基础异常"""
    pass

class AuthenticationError(APIError):
    """认证错误"""
    pass

class NotFoundError(APIError):
    """资源未找到错误"""
    pass

# 使用示例
def get_user(self, user_id: int) -> dict:
    try:
        response = self.get(f"{self.endpoint}/{user_id}")
        response.raise_for_status()
        return response.json()
    except httpx.HTTPStatusError as e:
        if e.response.status_code == 404:
            raise NotFoundError(f"用户 {user_id} 不存在") from e
        raise APIError(f"获取用户失败: {e}") from e
```

### 数据模型规范

使用 `dataclass` 或 `Pydantic` 定义数据模型：

```python
# framework/api/modules/user/user_schema.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class User:
    """用户数据模型"""
    id: int
    username: str
    email: str
    created_at: Optional[str] = None
    
    @classmethod
    def from_dict(cls, data: dict) -> "User":
        """从字典创建 User 实例"""
        return cls(**data)
```

### 配置管理规范

- 使用环境变量管理配置
- 提供默认值
- 支持多环境（开发、测试、生产）

```python
# framework/config/settings.py
import os
from typing import Optional

class Settings:
    """应用配置"""
    
    def __init__(self):
        self.base_url = os.getenv("BASE_URL", "https://api.example.com")
        self.timeout = int(os.getenv("TIMEOUT", "30"))
        self.api_key = os.getenv("API_KEY")
        
        if not self.api_key:
            raise ValueError("API_KEY 环境变量未设置")
```

---

## 注释和文档规范

### 文档字符串（Docstring）

- 所有公共函数、类、方法都应该有文档字符串
- 使用 Google 风格或 NumPy 风格的文档字符串

```python
def create_user(self, user_data: dict) -> dict:
    """创建新用户
    
    Args:
        user_data: 用户数据字典，包含 username, email, password 等字段
        
    Returns:
        包含创建用户信息的字典，包括用户 ID 和基本信息
        
    Raises:
        ValidationError: 当用户数据无效时
        APIError: 当 API 调用失败时
        
    Example:
        >>> client = UserClient(base_url="https://api.example.com")
        >>> user = client.create_user({
        ...     "username": "test_user",
        ...     "email": "test@example.com",
        ...     "password": "password123"
        ... })
        >>> print(user["id"])
        12345
    """
    pass
```

### 行内注释

- 解释"为什么"而不是"是什么"
- 避免显而易见的注释
- 使用中文注释（项目要求）

```python
# 好的注释
# 由于 API 限制，需要先获取 token 再调用其他接口
token = self._get_auth_token()

# 不好的注释
# 获取 token
token = self._get_auth_token()
```

### 类型注解

- 所有函数参数和返回值都应该有类型注解
- 使用 `typing` 模块提供的类型

```python
from typing import Dict, List, Optional, Union

def process_users(
    users: List[Dict[str, Union[str, int]]],
    filter_by: Optional[str] = None
) -> List[Dict[str, Union[str, int]]]:
    """处理用户列表"""
    pass
```

---

## 异常处理规范

### 异常捕获

- 只捕获预期的异常
- 使用具体的异常类型，避免使用裸露的 `except:`
- 记录异常信息
- 重新抛出时使用 `from` 保留异常链

```python
# 好的异常处理
try:
    response = self._make_request(url)
except httpx.TimeoutException as e:
    logger.error(f"请求超时: {url}")
    raise APIError(f"请求超时: {url}") from e
except httpx.HTTPStatusError as e:
    logger.error(f"HTTP 错误: {e.response.status_code}")
    raise APIError(f"HTTP 错误: {e.response.status_code}") from e

# 不好的异常处理
try:
    response = self._make_request(url)
except:  # 捕获所有异常，不推荐
    pass
```

### 自定义异常

- 继承自合适的基类
- 提供清晰的错误消息
- 包含有用的上下文信息

```python
class UserNotFoundError(NotFoundError):
    """用户未找到异常"""
    
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")
```

---

## 最佳实践

### 代码复用

- 将公共逻辑提取到工具函数或基类
- 使用 fixtures 共享测试设置
- 避免重复代码（DRY 原则）

### 性能优化

- 使用 `pytest-xdist` 并行运行测试
- 合理使用 fixture scope（function, class, module, session）
- 避免在测试中执行耗时的操作（如网络请求），使用 mock

### 可维护性

- 保持函数简短，单一职责
- 使用有意义的变量名
- 定期重构代码
- 遵循 SOLID 原则

### 安全性

- 不要在代码中硬编码敏感信息（密码、API 密钥等）
- 使用环境变量或配置文件管理敏感信息
- 不要在版本控制中提交 `.env` 文件

### 测试覆盖率

- 目标测试覆盖率：≥ 80%
- 使用 `pytest-cov` 检查覆盖率
- 重点关注核心业务逻辑的测试

```bash
# 运行测试并生成覆盖率报告
pytest --cov=framework --cov-report=html
```

### 代码审查

- 提交代码前运行 Ruff 检查
- 确保所有测试通过
- 代码审查时关注：
  - 代码风格一致性
  - 测试覆盖度
  - 错误处理
  - 文档完整性

---

## 总结

遵循本规范可以确保：

1. **代码质量**：统一的代码风格，易于阅读和维护
2. **团队协作**：减少代码审查时间，提高协作效率
3. **可维护性**：清晰的代码结构，便于后续维护和扩展
4. **测试可靠性**：规范的测试编写，提高测试的可信度

如有疑问或建议，请及时反馈和讨论。

