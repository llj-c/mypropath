# 测试任务管理实现方案

## 一、整体架构设计

### 1.1 核心组件

```
┌─────────────────────────────────────────────────────────┐
│                    FastAPI 主进程                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  任务管理器   │  │  状态存储     │  │  API路由     │ │
│  │ TaskManager  │  │ StateStore   │  │  Routes      │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                        │
                        │ 子进程启动
                        ▼
┌─────────────────────────────────────────────────────────┐
│              pytest 子进程（后台运行）                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ pytest钩子   │  │  状态检查器   │  │  日志收集器   │ │
│  │  Plugin      │  │ StateChecker │  │ LogCollector │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 1.2 状态流转

```
PENDING → RUNNING → PAUSED → RUNNING → COMPLETED
                ↓
            CANCELLED
                ↓
            DELETED
```

## 二、详细设计

### 2.1 任务管理器 (TaskManager)

**职责：**
- 管理测试任务的完整生命周期
- 启动/停止pytest子进程
- 与状态存储交互，更新任务状态
- 管理任务元数据（run_id, traceid, 日志路径等）

**关键方法：**
- `start_task(run_id, test_paths, options)` - 启动测试任务
- `pause_task(run_id)` - 暂停任务（设置暂停标志）
- `resume_task(run_id)` - 恢复任务（清除暂停标志）
- `cancel_task(run_id)` - 中止任务（设置中止标志，等待当前用例完成）
- `delete_task(run_id)` - 删除任务（清理资源）
- `get_task_status(run_id)` - 获取任务状态

**进程管理：**
- 使用 `subprocess.Popen` 启动pytest子进程
- Windows平台支持单独console窗口（通过 `creationflags=CREATE_NEW_CONSOLE`）
- 维护进程对象和进程ID的映射关系

### 2.2 状态存储 (StateStore)

**设计选择：**
- **方案A（推荐）**：使用Redis作为共享状态存储（支持多进程/多机器）
- **方案B**：使用内存字典 + 文件锁（单机多进程）
- **方案C**：使用SQLite + 文件锁（单机，支持持久化）

**状态结构：**
```python
{
    "run_id": {
        "status": "RUNNING",  # PENDING, RUNNING, PAUSED, CANCELLED, COMPLETED, FAILED
        "paused": False,      # 暂停标志
        "cancelled": False,   # 中止标志
        "process_id": 12345,  # 子进程ID
        "start_time": "...",
        "end_time": "...",
        "traceid": "...",
        "log_path": "...",
        "report_path": "..."
    }
}
```

**关键操作：**
- `set_status(run_id, status)` - 设置任务状态
- `set_flag(run_id, flag_name, value)` - 设置标志位（paused/cancelled）
- `get_status(run_id)` - 获取任务状态
- `check_flag(run_id, flag_name)` - 检查标志位
- `wait_for_flag(run_id, flag_name, timeout)` - 等待标志位变化（用于暂停恢复）

### 2.3 FastAPI 路由设计

**API端点：**

```
POST   /api/v1/tasks              # 创建并启动测试任务
GET    /api/v1/tasks/{run_id}     # 查询任务状态
POST   /api/v1/tasks/{run_id}/pause    # 暂停任务
POST   /api/v1/tasks/{run_id}/resume   # 恢复任务
POST   /api/v1/tasks/{run_id}/cancel   # 中止任务
DELETE /api/v1/tasks/{run_id}     # 删除任务
GET    /api/v1/tasks              # 查询任务列表
GET    /api/v1/tasks/{run_id}/report  # 获取测试报告
```

**请求/响应模型：**
- `TaskCreateRequest` - 创建任务请求（test_paths, options等）
- `TaskResponse` - 任务响应（run_id, status等）
- `TaskListResponse` - 任务列表响应

### 2.4 pytest 钩子插件

**插件功能：**
- 在pytest执行过程中定期检查任务状态
- 响应暂停/中止标志
- 收集日志并写入文件
- 生成traceid并传递给测试用例

**关键钩子：**
- `pytest_configure(config)` - 初始化插件，获取run_id
- `pytest_runtest_setup(item)` - 每个测试用例开始前检查状态
- `pytest_runtest_teardown(item)` - 每个测试用例结束后检查状态
- `pytest_collection_modifyitems(config, items)` - 收集阶段检查中止标志
- `pytest_sessionstart(session)` - 会话开始，设置traceid
- `pytest_sessionfinish(session)` - 会话结束，清理资源

**状态检查机制：**
```python
# 在测试用例执行前检查
if state_store.check_flag(run_id, "cancelled"):
    pytest.skip("任务已中止")
    
# 在测试用例执行间隙检查暂停
if state_store.check_flag(run_id, "paused"):
    state_store.wait_for_flag(run_id, "paused", timeout=None)  # 等待恢复
```

### 2.5 进程间通信

**方案：**
1. **状态存储**：主进程和子进程通过共享存储（Redis/文件）通信
2. **信号机制**：主进程可以发送信号给子进程（但pytest可能不响应）
3. **标志位轮询**：pytest插件定期轮询状态存储

**推荐方案：**
- 使用Redis作为状态存储（如果已配置）
- 或使用文件 + 文件锁（`fcntl` on Linux, `msvcrt` on Windows）
- pytest插件每执行一个测试用例前后检查标志位

### 2.6 日志管理

**日志结构：**
```
logs/
  └── {run_id}/
      ├── pytest.log          # pytest执行日志
      ├── test_{traceid}.log  # 单个测试用例日志
      └── framework.log       # 框架日志
```

**日志特性：**
- 每个测试用例有独立的traceid
- 日志同时写入文件和console（Windows平台）
- 使用Python logging模块，支持多handler

### 2.7 测试报告管理

**报告存储：**
```
reports/
  └── {run_id}/
      ├── report.html         # pytest-html报告
      └── junit.xml           # JUnit格式报告（可选）
```

**报告清理：**
- 默认保留最近7次测试报告
- 删除任务时可以选择是否删除报告
- 提供API查询历史报告

## 三、实现细节

### 3.1 任务ID生成

```python
import uuid
from datetime import datetime

def generate_run_id() -> str:
    """生成唯一的run_id"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    unique_id = str(uuid.uuid4())[:8]
    return f"test_{timestamp}_{unique_id}"
```

### 3.2 traceid管理

```python
import contextvars

# 使用contextvars确保traceid在异步环境中正确传递
traceid_context: contextvars.ContextVar[str] = contextvars.ContextVar('traceid')

def get_traceid() -> str:
    """获取当前测试用例的traceid"""
    return traceid_context.get("unknown")
```

### 3.3 暂停/恢复机制

```python
# 主进程：设置暂停标志
state_store.set_flag(run_id, "paused", True)

# pytest进程：检查并等待
if state_store.check_flag(run_id, "paused"):
    # 使用条件变量或轮询等待
    while state_store.check_flag(run_id, "paused"):
        time.sleep(0.5)  # 轮询间隔
```

### 3.4 中止机制

```python
# 主进程：设置中止标志
state_store.set_flag(run_id, "cancelled", True)

# pytest进程：检查中止标志
if state_store.check_flag(run_id, "cancelled"):
    # 跳过后续测试用例
    pytest.skip("任务已中止")
    
# 注意：正在运行的测试用例会继续执行完成
```

### 3.5 Windows Console支持

```python
import sys
import subprocess

def start_pytest_subprocess(run_id, test_paths, show_console=False):
    """启动pytest子进程"""
    cmd = ["pytest"] + test_paths + ["--run-id", run_id]
    
    if sys.platform == "win32" and show_console:
        # Windows: 创建新的console窗口
        creation_flags = subprocess.CREATE_NEW_CONSOLE
    else:
        creation_flags = 0
    
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        creationflags=creation_flags
    )
    return process
```

## 四、数据模型设计

### 4.1 任务状态枚举

```python
from enum import Enum

class TaskStatus(str, Enum):
    PENDING = "PENDING"      # 等待启动
    RUNNING = "RUNNING"      # 运行中
    PAUSED = "PAUSED"        # 已暂停
    CANCELLED = "CANCELLED"  # 已中止
    COMPLETED = "COMPLETED"  # 已完成
    FAILED = "FAILED"        # 执行失败
```

### 4.2 请求/响应模型

```python
class TaskCreateRequest(BaseModel):
    test_paths: List[str]  # 测试路径
    options: Dict[str, Any]  # pytest选项
    show_console: bool = False  # Windows平台是否显示console

class TaskResponse(BaseModel):
    run_id: str
    status: TaskStatus
    start_time: Optional[datetime]
    end_time: Optional[datetime]
    log_path: Optional[str]
    report_path: Optional[str]
```

## 五、依赖注入设计

### 5.1 容器配置

```python
class FW_Container(containers.DeclarativeContainer):
    fw_config = providers.Singleton(FWConfig)
    state_store = providers.Singleton(StateStore, config=fw_config)
    task_manager = providers.Singleton(
        TaskManager, 
        state_store=state_store,
        config=fw_config
    )
```

## 六、错误处理

### 6.1 异常类型

- `TaskNotFoundError` - 任务不存在
- `TaskAlreadyRunningError` - 任务已在运行
- `TaskNotPausableError` - 任务无法暂停（非运行状态）
- `TaskNotResumableError` - 任务无法恢复（非暂停状态）

## 七、性能考虑

1. **状态轮询频率**：pytest插件每执行一个测试用例检查一次，避免过于频繁
2. **状态存储选择**：Redis > 内存字典 > SQLite（根据并发需求选择）
3. **日志写入**：使用异步日志handler或缓冲写入
4. **报告生成**：在后台异步生成，不阻塞任务完成

## 八、扩展性

1. **多任务并发**：支持同时运行多个测试任务
2. **任务队列**：未来可以添加任务队列机制
3. **分布式执行**：通过Redis状态存储，可以支持分布式执行
4. **WebSocket支持**：实时推送任务状态更新

